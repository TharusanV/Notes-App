/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

var LexicalComposerContext = require('@lexical/react/LexicalComposerContext');
var utils = require('@lexical/utils');
var lexical = require('lexical');
var React = require('react');

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
const CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
const useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;
var useLayoutEffect = useLayoutEffectImpl;

/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */
const PUNCTUATION = '\\.,\\+\\*\\?\\$\\@\\|#{}\\(\\)\\^\\-\\[\\]\\\\/!%\'"~=<>_:;';
class TypeaheadOption {
  constructor(key) {
    this.key = key;
    this.ref = {
      current: null
    };
    this.setRefElement = this.setRefElement.bind(this);
  }

  setRefElement(element) {
    this.ref = {
      current: element
    };
  }

}

const scrollIntoViewIfNeeded = target => {
  const container = document.getElementById('typeahead-menu');

  if (container) {
    const containerRect = container.getBoundingClientRect();
    const targetRect = target.getBoundingClientRect();

    if (targetRect.bottom > containerRect.bottom) {
      target.scrollIntoView(false);
    } else if (targetRect.top < containerRect.top) {
      target.scrollIntoView();
    }
  }
};

function getTextUpToAnchor(selection) {
  const anchor = selection.anchor;

  if (anchor.type !== 'text') {
    return null;
  }

  const anchorNode = anchor.getNode();

  if (!anchorNode.isSimpleText()) {
    return null;
  }

  const anchorOffset = anchor.offset;
  return anchorNode.getTextContent().slice(0, anchorOffset);
}

function tryToPositionRange(leadOffset, range) {
  const domSelection = window.getSelection();

  if (domSelection === null || !domSelection.isCollapsed) {
    return false;
  }

  const anchorNode = domSelection.anchorNode;
  const startOffset = leadOffset;
  const endOffset = domSelection.anchorOffset;

  if (anchorNode == null || endOffset == null) {
    return false;
  }

  try {
    range.setStart(anchorNode, startOffset);
    range.setEnd(anchorNode, endOffset);
  } catch (error) {
    return false;
  }

  return true;
}

function getQueryTextForSearch(editor) {
  let text = null;
  editor.getEditorState().read(() => {
    const selection = lexical.$getSelection();

    if (!lexical.$isRangeSelection(selection)) {
      return;
    }

    text = getTextUpToAnchor(selection);
  });
  return text;
}
/**
 * Walk backwards along user input and forward through entity title to try
 * and replace more of the user's text with entity.
 */


function getFullMatchOffset(documentText, entryText, offset) {
  let triggerOffset = offset;

  for (let i = triggerOffset; i <= entryText.length; i++) {
    if (documentText.substr(-i) === entryText.substr(0, i)) {
      triggerOffset = i;
    }
  }

  return triggerOffset;
}
/**
 * Split Lexical TextNode and return a new TextNode only containing matched text.
 * Common use cases include: removing the node, replacing with a new node.
 */


function splitNodeContainingQuery(editor, match) {
  const selection = lexical.$getSelection();

  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
    return null;
  }

  const anchor = selection.anchor;

  if (anchor.type !== 'text') {
    return null;
  }

  const anchorNode = anchor.getNode();

  if (!anchorNode.isSimpleText()) {
    return null;
  }

  const selectionOffset = anchor.offset;
  const textContent = anchorNode.getTextContent().slice(0, selectionOffset);
  const characterOffset = match.replaceableString.length;
  const queryOffset = getFullMatchOffset(textContent, match.matchingString, characterOffset);
  const startOffset = selectionOffset - queryOffset;

  if (startOffset < 0) {
    return null;
  }

  let newNode;

  if (startOffset === 0) {
    [newNode] = anchorNode.splitText(selectionOffset);
  } else {
    [, newNode] = anchorNode.splitText(startOffset, selectionOffset);
  }

  return newNode;
}

function isSelectionOnEntityBoundary(editor, offset) {
  if (offset !== 0) {
    return false;
  }

  return editor.getEditorState().read(() => {
    const selection = lexical.$getSelection();

    if (lexical.$isRangeSelection(selection)) {
      const anchor = selection.anchor;
      const anchorNode = anchor.getNode();
      const prevSibling = anchorNode.getPreviousSibling();
      return lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity();
    }

    return false;
  });
}

function startTransition(callback) {
  if (React.startTransition) {
    React.startTransition(callback);
  } else {
    callback();
  }
}

function LexicalPopoverMenu({
  close,
  editor,
  anchorElement,
  resolution,
  options,
  menuRenderFn,
  onSelectOption
}) {
  const [selectedIndex, setHighlightedIndex] = React.useState(null);
  React.useEffect(() => {
    setHighlightedIndex(0);
  }, [resolution.match.matchingString]);
  const selectOptionAndCleanUp = React.useCallback(selectedEntry => {
    editor.update(() => {
      const textNodeContainingQuery = splitNodeContainingQuery(editor, resolution.match);
      onSelectOption(selectedEntry, textNodeContainingQuery, close, resolution.match.matchingString);
    });
  }, [close, editor, resolution.match, onSelectOption]);
  const updateSelectedIndex = React.useCallback(index => {
    const rootElem = editor.getRootElement();

    if (rootElem !== null) {
      rootElem.setAttribute('aria-activedescendant', 'typeahead-item-' + index);
      setHighlightedIndex(index);
    }
  }, [editor]);
  React.useEffect(() => {
    return () => {
      const rootElem = editor.getRootElement();

      if (rootElem !== null) {
        rootElem.removeAttribute('aria-activedescendant');
      }
    };
  }, [editor]);
  useLayoutEffect(() => {
    if (options === null) {
      setHighlightedIndex(null);
    } else if (selectedIndex === null) {
      updateSelectedIndex(0);
    }
  }, [options, selectedIndex, updateSelectedIndex]);
  React.useEffect(() => {
    return utils.mergeRegister(editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, payload => {
      const event = payload;

      if (options !== null && options.length && selectedIndex !== null) {
        const newSelectedIndex = selectedIndex !== options.length - 1 ? selectedIndex + 1 : 0;
        updateSelectedIndex(newSelectedIndex);
        const option = options[newSelectedIndex];

        if (option.ref != null && option.ref.current) {
          scrollIntoViewIfNeeded(option.ref.current);
        }

        event.preventDefault();
        event.stopImmediatePropagation();
      }

      return true;
    }, lexical.COMMAND_PRIORITY_NORMAL), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, payload => {
      const event = payload;

      if (options !== null && options.length && selectedIndex !== null) {
        const newSelectedIndex = selectedIndex !== 0 ? selectedIndex - 1 : options.length - 1;
        updateSelectedIndex(newSelectedIndex);
        const option = options[newSelectedIndex];

        if (option.ref != null && option.ref.current) {
          scrollIntoViewIfNeeded(option.ref.current);
        }

        event.preventDefault();
        event.stopImmediatePropagation();
      }

      return true;
    }, lexical.COMMAND_PRIORITY_NORMAL), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, payload => {
      const event = payload;
      event.preventDefault();
      event.stopImmediatePropagation();
      close();
      return true;
    }, lexical.COMMAND_PRIORITY_NORMAL), editor.registerCommand(lexical.KEY_TAB_COMMAND, payload => {
      const event = payload;

      if (options === null || selectedIndex === null || options[selectedIndex] == null) {
        return false;
      }

      event.preventDefault();
      event.stopImmediatePropagation();
      selectOptionAndCleanUp(options[selectedIndex]);
      return true;
    }, lexical.COMMAND_PRIORITY_NORMAL), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {
      if (options === null || selectedIndex === null || options[selectedIndex] == null) {
        return false;
      }

      if (event !== null) {
        event.preventDefault();
        event.stopImmediatePropagation();
      }

      selectOptionAndCleanUp(options[selectedIndex]);
      return true;
    }, lexical.COMMAND_PRIORITY_NORMAL));
  }, [selectOptionAndCleanUp, close, editor, options, selectedIndex, updateSelectedIndex]);
  const listItemProps = React.useMemo(() => ({
    selectOptionAndCleanUp,
    selectedIndex,
    setHighlightedIndex
  }), [selectOptionAndCleanUp, selectedIndex]);
  return menuRenderFn(anchorElement, listItemProps, resolution.match.matchingString);
}

function useBasicTypeaheadTriggerMatch(trigger, {
  minLength = 1,
  maxLength = 75
}) {
  return React.useCallback(text => {
    const validChars = '[^' + trigger + PUNCTUATION + '\\s]';
    const TypeaheadTriggerRegex = new RegExp('(^|\\s|\\()(' + '[' + trigger + ']' + '((?:' + validChars + '){0,' + maxLength + '})' + ')$');
    const match = TypeaheadTriggerRegex.exec(text);

    if (match !== null) {
      const maybeLeadingWhitespace = match[1];
      const matchingString = match[3];

      if (matchingString.length >= minLength) {
        return {
          leadOffset: match.index + maybeLeadingWhitespace.length,
          matchingString,
          replaceableString: match[2]
        };
      }
    }

    return null;
  }, [maxLength, minLength, trigger]);
}

function useAnchorElementRef(resolution) {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const anchorElementRef = React.useRef(document.createElement('div'));
  React.useEffect(() => {
    const rootElement = editor.getRootElement();

    function positionMenu() {
      const containerDiv = anchorElementRef.current;
      containerDiv.setAttribute('aria-label', 'Typeahead menu');
      containerDiv.setAttribute('id', 'typeahead-menu');
      containerDiv.setAttribute('role', 'listbox');

      if (rootElement !== null && resolution !== null) {
        const {
          left,
          top,
          width,
          height
        } = resolution.getRect();
        containerDiv.style.top = `${top + height + 5 + window.pageYOffset}px`;
        containerDiv.style.left = `${left + (resolution.position === 'start' ? 0 : width) + window.pageXOffset}px`;
        containerDiv.style.display = 'block';
        containerDiv.style.position = 'absolute';

        if (!containerDiv.isConnected) {
          document.body.append(containerDiv);
        }

        anchorElementRef.current = containerDiv;
        rootElement.setAttribute('aria-controls', 'typeahead-menu');
      }
    }

    if (resolution !== null) {
      positionMenu();
      window.addEventListener('resize', positionMenu);
      return () => {
        window.removeEventListener('resize', positionMenu);

        if (rootElement !== null) {
          rootElement.removeAttribute('aria-controls');
        }
      };
    }
  }, [editor, resolution]);
  return anchorElementRef;
}

function LexicalTypeaheadMenuPlugin({
  options,
  onQueryChange,
  onSelectOption,
  menuRenderFn,
  triggerFn,
  position = 'start'
}) {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const [resolution, setResolution] = React.useState(null);
  const anchorElementRef = useAnchorElementRef(resolution);
  React.useEffect(() => {
    let activeRange = document.createRange();

    const updateListener = () => {
      editor.getEditorState().read(() => {
        const range = activeRange;
        const selection = lexical.$getSelection();
        const text = getQueryTextForSearch(editor);

        if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed() || text === null || range === null) {
          setResolution(null);
          return;
        }

        const match = triggerFn(text, editor);
        onQueryChange(match ? match.matchingString : null);

        if (match !== null && !isSelectionOnEntityBoundary(editor, match.leadOffset)) {
          const isRangePositioned = tryToPositionRange(match.leadOffset, range);

          if (isRangePositioned !== null) {
            startTransition(() => setResolution({
              getRect: () => range.getBoundingClientRect(),
              match,
              position
            }));
            return;
          }
        }

        setResolution(null);
      });
    };

    const removeUpdateListener = editor.registerUpdateListener(updateListener);
    return () => {
      activeRange = null;
      removeUpdateListener();
    };
  }, [editor, triggerFn, onQueryChange, resolution, position]);
  const closeTypeahead = React.useCallback(() => {
    setResolution(null);
  }, []);
  return resolution === null || editor === null ? null : /*#__PURE__*/React.createElement(LexicalPopoverMenu, {
    close: closeTypeahead,
    resolution: resolution,
    editor: editor,
    anchorElement: anchorElementRef.current,
    options: options,
    menuRenderFn: menuRenderFn,
    onSelectOption: onSelectOption
  });
}
function LexicalNodeMenuPlugin({
  options,
  nodeKey,
  position = 'end',
  onClose,
  onSelectOption,
  menuRenderFn
}) {
  const [editor] = LexicalComposerContext.useLexicalComposerContext();
  const [resolution, setResolution] = React.useState(null);
  const anchorElementRef = useAnchorElementRef(resolution);
  React.useEffect(() => {
    if (nodeKey && resolution == null) {
      editor.update(() => {
        const node = lexical.$getNodeByKey(nodeKey);
        const domElement = editor.getElementByKey(nodeKey);

        if (node != null && domElement != null) {
          const text = node.getTextContent();
          startTransition(() => setResolution({
            getRect: () => domElement.getBoundingClientRect(),
            match: {
              leadOffset: text.length,
              matchingString: text,
              replaceableString: text
            },
            position
          }));
        }
      });
    } else if (nodeKey == null && resolution != null) {
      setResolution(null);
    }
  }, [editor, nodeKey, position, resolution]);
  return resolution === null || editor === null ? null : /*#__PURE__*/React.createElement(LexicalPopoverMenu, {
    close: onClose,
    resolution: resolution,
    editor: editor,
    anchorElement: anchorElementRef.current,
    options: options,
    menuRenderFn: menuRenderFn,
    onSelectOption: onSelectOption
  });
}

exports.LexicalNodeMenuPlugin = LexicalNodeMenuPlugin;
exports.LexicalTypeaheadMenuPlugin = LexicalTypeaheadMenuPlugin;
exports.PUNCTUATION = PUNCTUATION;
exports.TypeaheadOption = TypeaheadOption;
exports.useBasicTypeaheadTriggerMatch = useBasicTypeaheadTriggerMatch;
