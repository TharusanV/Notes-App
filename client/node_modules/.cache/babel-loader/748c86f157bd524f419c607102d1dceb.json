{"ast":null,"code":"import { combineTransactionSteps, getChangedRanges, getMarksBetween, findChildrenInRange, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { test, find, registerCustomProtocol } from 'linkifyjs';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n      const {\n        tr\n      } = newState;\n      const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n      const {\n        mapping\n      } = transform;\n      const changes = getChangedRanges(transform);\n      changes.forEach(_ref => {\n        let {\n          oldRange,\n          newRange\n        } = _ref;\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter(item => item.mark.type === options.type).forEach(oldMark => {\n          const newFrom = mapping.map(oldMark.from);\n          const newTo = mapping.map(oldMark.to);\n          const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter(item => item.mark.type === options.type);\n          if (!newMarks.length) {\n            return;\n          }\n          const newMark = newMarks[0];\n          const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ');\n          const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ');\n          const wasLink = test(oldLinkText);\n          const isLink = test(newLinkText);\n          // remove only the link, if it was a link before too\n          // because we don’t want to remove links that were set manually\n          if (wasLink && !isLink) {\n            tr.removeMark(newMark.from, newMark.to, options.type);\n          }\n        });\n        // now let’s see if we can add new links\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock);\n        let textBlock;\n        let textBeforeWhitespace;\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter)\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n        } else if (nodesInChangedRanges.length\n        // We want to make sure to include the block seperator argument to treat hard breaks like spaces\n        && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')) {\n          textBlock = nodesInChangedRanges[0];\n          textBeforeWhitespace = newState.doc.textBetween(textBlock.pos, newRange.to, undefined, ' ');\n        }\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '');\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false;\n          }\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1];\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace);\n          if (!lastWordBeforeSpace) {\n            return false;\n          }\n          find(lastWordBeforeSpace).filter(link => link.isLink).filter(link => {\n            if (options.validate) {\n              return options.validate(link.value);\n            }\n            return true;\n          })\n          // calculate link position\n          .map(link => ({\n            ...link,\n            from: lastWordAndBlockOffset + link.start + 1,\n            to: lastWordAndBlockOffset + link.end + 1\n          }))\n          // add link mark\n          .forEach(link => {\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        }\n      });\n      if (!tr.steps.length) {\n        return;\n      }\n      return tr;\n    }\n  });\n}\nfunction clickHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a;\n        const attrs = getAttributes(view.state, options.type.name);\n        const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('a');\n        if (link && attrs.href) {\n          window.open(attrs.href, attrs.target);\n          return true;\n        }\n        return false;\n      }\n    }\n  });\n}\nfunction pasteHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const {\n          state\n        } = view;\n        const {\n          selection\n        } = state;\n        const {\n          empty\n        } = selection;\n        if (empty) {\n          return false;\n        }\n        let textContent = '';\n        slice.content.forEach(node => {\n          textContent += node.textContent;\n        });\n        const link = find(textContent).find(item => item.isLink && item.value === textContent);\n        if (!textContent || !link) {\n          return false;\n        }\n        options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n        return true;\n      }\n    }\n  });\n}\nconst Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  keepOnSplit: false,\n  onCreate() {\n    this.options.protocols.forEach(registerCustomProtocol);\n  },\n  inclusive() {\n    return this.options.autolink;\n  },\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null\n      },\n      validate: undefined\n    };\n  },\n  addAttributes() {\n    return {\n      href: {\n        default: null\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n  parseHTML() {\n    return [{\n      tag: 'a[href]:not([href *= \"javascript:\" i])'\n    }];\n  },\n  renderHTML(_ref2) {\n    let {\n      HTMLAttributes\n    } = _ref2;\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n  addCommands() {\n    return {\n      setLink: attributes => _ref3 => {\n        let {\n          chain\n        } = _ref3;\n        return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n      },\n      toggleLink: attributes => _ref4 => {\n        let {\n          chain\n        } = _ref4;\n        return chain().toggleMark(this.name, attributes, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      },\n      unsetLink: () => _ref5 => {\n        let {\n          chain\n        } = _ref5;\n        return chain().unsetMark(this.name, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      }\n    };\n  },\n  addPasteRules() {\n    return [markPasteRule({\n      find: text => find(text).filter(link => {\n        if (this.options.validate) {\n          return this.options.validate(link.value);\n        }\n        return true;\n      }).filter(link => link.isLink).map(link => ({\n        text: link.value,\n        index: link.start,\n        data: link\n      })),\n      type: this.type,\n      getAttributes: match => {\n        var _a;\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n  addProseMirrorPlugins() {\n    const plugins = [];\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        validate: this.options.validate\n      }));\n    }\n    if (this.options.openOnClick) {\n      plugins.push(clickHandler({\n        type: this.type\n      }));\n    }\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        type: this.type\n      }));\n    }\n    return plugins;\n  }\n});\nexport { Link, Link as default };","map":{"version":3,"mappings":"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","names":["autolink","options","Plugin","key","PluginKey","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","doc","eq","preventAutolink","getMeta","tr","transform","combineTransactionSteps","mapping","changes","getChangedRanges","forEach","oldRange","newRange","getMarksBetween","from","to","filter","item","mark","type","oldMark","newFrom","map","newTo","newMarks","length","newMark","oldLinkText","textBetween","undefined","newLinkText","wasLink","test","isLink","removeMark","nodesInChangedRanges","findChildrenInRange","node","isTextblock","textBlock","textBeforeWhitespace","pos","nodeSize","endsWith","wordsBeforeWhitespace","split","s","lastWordBeforeSpace","lastWordAndBlockOffset","lastIndexOf","find","link","validate","value","start","end","addMark","create","href","steps","clickHandler","props","handleClick","view","event","attrs","getAttributes","state","name","target","closest","window","open","pasteHandler","handlePaste","slice","selection","empty","textContent","content","editor","commands","setMark","Mark","priority","keepOnSplit","onCreate","protocols","registerCustomProtocol","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","rel","class","addAttributes","default","parseHTML","tag","renderHTML","mergeAttributes","addCommands","setLink","attributes","chain","setMeta","run","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","markPasteRule","text","index","data","match","addProseMirrorPlugins","plugins","push"],"sources":["E:\\0TUser18\\Downloads\\Projects\\Notes App\\client\\node_modules\\@tiptap\\extension-link\\src\\helpers\\autolink.ts","E:\\0TUser18\\Downloads\\Projects\\Notes App\\client\\node_modules\\@tiptap\\extension-link\\src\\helpers\\clickHandler.ts","E:\\0TUser18\\Downloads\\Projects\\Notes App\\client\\node_modules\\@tiptap\\extension-link\\src\\helpers\\pasteHandler.ts","E:\\0TUser18\\Downloads\\Projects\\Notes App\\client\\node_modules\\@tiptap\\extension-link\\src\\link.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  findChildrenInRange,\n  getChangedRanges,\n  getMarksBetween,\n  NodeWithPos,\n} from '@tiptap/core'\nimport { find, test } from 'linkifyjs'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype AutolinkOptions = {\n  type: MarkType,\n  validate?: (url: string) => boolean,\n}\n\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some(transaction => transaction.docChanged)\n        && !oldState.doc.eq(newState.doc)\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const { mapping } = transform\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ oldRange, newRange }) => {\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc)\n          .filter(item => item.mark.type === options.type)\n          .forEach(oldMark => {\n            const newFrom = mapping.map(oldMark.from)\n            const newTo = mapping.map(oldMark.to)\n            const newMarks = getMarksBetween(newFrom, newTo, newState.doc)\n              .filter(item => item.mark.type === options.type)\n\n            if (!newMarks.length) {\n              return\n            }\n\n            const newMark = newMarks[0]\n            const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ')\n            const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ')\n            const wasLink = test(oldLinkText)\n            const isLink = test(newLinkText)\n\n            // remove only the link, if it was a link before too\n            // because we don’t want to remove links that were set manually\n            if (wasLink && !isLink) {\n              tr.removeMark(newMark.from, newMark.to, options.type)\n            }\n          })\n\n        // now let’s see if we can add new links\n        const nodesInChangedRanges = findChildrenInRange(newState.doc, newRange, node => node.isTextblock)\n\n        let textBlock: NodeWithPos | undefined\n        let textBeforeWhitespace: string | undefined\n\n        if (nodesInChangedRanges.length > 1) {\n          // Grab the first node within the changed ranges (ex. the first of two paragraphs when hitting enter)\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            textBlock.pos + textBlock.node.nodeSize,\n            undefined,\n            ' ',\n          )\n        } else if (\n          nodesInChangedRanges.length\n          // We want to make sure to include the block seperator argument to treat hard breaks like spaces\n          && newState.doc.textBetween(newRange.from, newRange.to, ' ', ' ').endsWith(' ')\n        ) {\n          textBlock = nodesInChangedRanges[0]\n          textBeforeWhitespace = newState.doc.textBetween(\n            textBlock.pos,\n            newRange.to,\n            undefined,\n            ' ',\n          )\n        }\n\n        if (textBlock && textBeforeWhitespace) {\n          const wordsBeforeWhitespace = textBeforeWhitespace.split(' ').filter(s => s !== '')\n\n          if (wordsBeforeWhitespace.length <= 0) {\n            return false\n          }\n\n          const lastWordBeforeSpace = wordsBeforeWhitespace[wordsBeforeWhitespace.length - 1]\n          const lastWordAndBlockOffset = textBlock.pos + textBeforeWhitespace.lastIndexOf(lastWordBeforeSpace)\n\n          if (!lastWordBeforeSpace) {\n            return false\n          }\n\n          find(lastWordBeforeSpace)\n            .filter(link => link.isLink)\n            .filter(link => {\n              if (options.validate) {\n                return options.validate(link.value)\n              }\n              return true\n            })\n            // calculate link position\n            .map(link => ({\n              ...link,\n              from: lastWordAndBlockOffset + link.start + 1,\n              to: lastWordAndBlockOffset + link.end + 1,\n            }))\n            // add link mark\n            .forEach(link => {\n              tr.addMark(link.from, link.to, options.type.create({\n                href: link.href,\n              }))\n            })\n        }\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","import { getAttributes } from '@tiptap/core'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype ClickHandlerOptions = {\n  type: MarkType,\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        const attrs = getAttributes(view.state, options.type.name)\n        const link = (event.target as HTMLElement)?.closest('a')\n\n        if (link && attrs.href) {\n          window.open(attrs.href, attrs.target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n","import { Editor } from '@tiptap/core'\nimport { find } from 'linkifyjs'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype PasteHandlerOptions = {\n  editor: Editor,\n  type: MarkType,\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent).find(item => item.isLink && item.value === textContent)\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n\n        return true\n      },\n    },\n  })\n}\n","import { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport { find, registerCustomProtocol } from 'linkifyjs'\nimport { Plugin } from 'prosemirror-state'\n\nimport { autolink } from './helpers/autolink'\nimport { clickHandler } from './helpers/clickHandler'\nimport { pasteHandler } from './helpers/pasteHandler'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, it adds links as you type.\n   */\n  autolink: boolean,\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   */\n  protocols: Array<string>,\n  /**\n   * If enabled, links will be opened on click.\n   */\n  openOnClick: boolean,\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   */\n  linkOnPaste: boolean,\n  /**\n   * A list of HTML attributes to be rendered.\n   */\n  HTMLAttributes: Record<string, any>,\n  /**\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate?: (url: string) => boolean,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       */\n      setLink: (attributes: { href: string, target?: string }) => ReturnType,\n      /**\n       * Toggle a link mark\n       */\n      toggleLink: (attributes: { href: string, target?: string }) => ReturnType,\n      /**\n       * Unset a link mark\n       */\n      unsetLink: () => ReturnType,\n    }\n  }\n}\n\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  onCreate() {\n    this.options.protocols.forEach(registerCustomProtocol)\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      validate: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      { tag: 'a[href]:not([href *= \"javascript:\" i])' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      'a',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ]\n  },\n\n  addCommands() {\n    return {\n      setLink: attributes => ({ chain }) => {\n        return chain()\n          .setMark(this.name, attributes)\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n\n      toggleLink: attributes => ({ chain }) => {\n        return chain()\n          .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n\n      unsetLink: () => ({ chain }) => {\n        return chain()\n          .unsetMark(this.name, { extendEmptyMarkRange: true })\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => find(text)\n          .filter(link => {\n            if (this.options.validate) {\n              return this.options.validate(link.value)\n            }\n\n            return true\n          })\n          .filter(link => link.isLink)\n          .map(link => ({\n            text: link.value,\n            index: link.start,\n            data: link,\n          })),\n        type: this.type,\n        getAttributes: match => ({\n          href: match.data?.href,\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins: Plugin[] = []\n\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        validate: this.options.validate,\n      }))\n    }\n\n    if (this.options.openOnClick) {\n      plugins.push(clickHandler({\n        type: this.type,\n      }))\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        type: this.type,\n      }))\n    }\n\n    return plugins\n  },\n})\n"]},"metadata":{},"sourceType":"module"}