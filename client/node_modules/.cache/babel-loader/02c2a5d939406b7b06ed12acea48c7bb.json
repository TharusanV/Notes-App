{"ast":null,"code":"/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n * @typedef {import('unist-util-is').Test} Test\r\n * @typedef {import('./complex-types.js').Action} Action\r\n * @typedef {import('./complex-types.js').Index} Index\r\n * @typedef {import('./complex-types.js').ActionTuple} ActionTuple\r\n * @typedef {import('./complex-types.js').VisitorResult} VisitorResult\r\n * @typedef {import('./complex-types.js').Visitor} Visitor\r\n */\n\nimport { convert } from 'unist-util-is';\nimport { color } from './color.js';\n\n/**\r\n * Continue traversing as normal\r\n */\nexport const CONTINUE = true;\n/**\r\n * Do not traverse this node’s children\r\n */\nexport const SKIP = 'skip';\n/**\r\n * Stop traversing immediately\r\n */\nexport const EXIT = false;\n\n/**\r\n * Visit children of tree which pass test.\r\n *\r\n * @param tree\r\n *   Tree to walk\r\n * @param [test]\r\n *   `unist-util-is`-compatible test\r\n * @param visitor\r\n *   Function called for nodes that pass `test`.\r\n * @param [reverse=false]\r\n *   Traverse in reverse preorder (NRL) instead of preorder (NLR) (default).\r\n */\nexport const visitParents =\n/**\r\n * @type {(\r\n *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types.js').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\r\n *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types.js').BuildVisitor<Tree>, reverse?: boolean) => void)\r\n * )}\r\n */\n\n/**\r\n * @param {Node} tree\r\n * @param {Test} test\r\n * @param {import('./complex-types.js').Visitor<Node>} visitor\r\n * @param {boolean} [reverse=false]\r\n */\nfunction (tree, test, visitor, reverse) {\n  if (typeof test === 'function' && typeof visitor !== 'function') {\n    reverse = visitor;\n    // @ts-expect-error no visitor given, so `visitor` is test.\n    visitor = test;\n    test = null;\n  }\n  const is = convert(test);\n  const step = reverse ? -1 : 1;\n  factory(tree, null, [])();\n\n  /**\r\n   * @param {Node} node\r\n   * @param {number?} index\r\n   * @param {Array<Parent>} parents\r\n   */\n  function factory(node, index, parents) {\n    /** @type {Record<string, unknown>} */\n    // @ts-expect-error: hush\n    const value = typeof node === 'object' && node !== null ? node : {};\n    /** @type {string|undefined} */\n    let name;\n    if (typeof value.type === 'string') {\n      name = typeof value.tagName === 'string' ? value.tagName : typeof value.name === 'string' ? value.name : undefined;\n      Object.defineProperty(visit, 'name', {\n        value: 'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'\n      });\n    }\n    return visit;\n    function visit() {\n      /** @type {ActionTuple} */\n      let result = [];\n      /** @type {ActionTuple} */\n      let subresult;\n      /** @type {number} */\n      let offset;\n      /** @type {Array<Parent>} */\n      let grandparents;\n      if (!test || is(node, index, parents[parents.length - 1] || null)) {\n        result = toResult(visitor(node, parents));\n        if (result[0] === EXIT) {\n          return result;\n        }\n      }\n\n      // @ts-expect-error looks like a parent.\n      if (node.children && result[0] !== SKIP) {\n        // @ts-expect-error looks like a parent.\n        offset = (reverse ? node.children.length : -1) + step;\n        // @ts-expect-error looks like a parent.\n        grandparents = parents.concat(node);\n\n        // @ts-expect-error looks like a parent.\n        while (offset > -1 && offset < node.children.length) {\n          // @ts-expect-error looks like a parent.\n          subresult = factory(node.children[offset], offset, grandparents)();\n          if (subresult[0] === EXIT) {\n            return subresult;\n          }\n          offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;\n        }\n      }\n      return result;\n    }\n  }\n};\n\n/**\r\n * @param {VisitorResult} value\r\n * @returns {ActionTuple}\r\n */\nfunction toResult(value) {\n  if (Array.isArray(value)) {\n    return value;\n  }\n  if (typeof value === 'number') {\n    return [CONTINUE, value];\n  }\n  return [value];\n}","map":{"version":3,"names":["convert","color","CONTINUE","SKIP","EXIT","visitParents","tree","test","visitor","reverse","is","step","factory","node","index","parents","value","name","type","tagName","undefined","Object","defineProperty","visit","result","subresult","offset","grandparents","length","toResult","children","concat","Array","isArray"],"sources":["E:/0TUser18/Downloads/Projects/Notes App/client/node_modules/unist-util-visit-parents/index.js"],"sourcesContent":["/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n * @typedef {import('unist-util-is').Test} Test\r\n * @typedef {import('./complex-types.js').Action} Action\r\n * @typedef {import('./complex-types.js').Index} Index\r\n * @typedef {import('./complex-types.js').ActionTuple} ActionTuple\r\n * @typedef {import('./complex-types.js').VisitorResult} VisitorResult\r\n * @typedef {import('./complex-types.js').Visitor} Visitor\r\n */\r\n\r\nimport {convert} from 'unist-util-is'\r\nimport {color} from './color.js'\r\n\r\n/**\r\n * Continue traversing as normal\r\n */\r\nexport const CONTINUE = true\r\n/**\r\n * Do not traverse this node’s children\r\n */\r\nexport const SKIP = 'skip'\r\n/**\r\n * Stop traversing immediately\r\n */\r\nexport const EXIT = false\r\n\r\n/**\r\n * Visit children of tree which pass test.\r\n *\r\n * @param tree\r\n *   Tree to walk\r\n * @param [test]\r\n *   `unist-util-is`-compatible test\r\n * @param visitor\r\n *   Function called for nodes that pass `test`.\r\n * @param [reverse=false]\r\n *   Traverse in reverse preorder (NRL) instead of preorder (NLR) (default).\r\n */\r\nexport const visitParents =\r\n  /**\r\n   * @type {(\r\n   *   (<Tree extends Node, Check extends Test>(tree: Tree, test: Check, visitor: import('./complex-types.js').BuildVisitor<Tree, Check>, reverse?: boolean) => void) &\r\n   *   (<Tree extends Node>(tree: Tree, visitor: import('./complex-types.js').BuildVisitor<Tree>, reverse?: boolean) => void)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * @param {Node} tree\r\n     * @param {Test} test\r\n     * @param {import('./complex-types.js').Visitor<Node>} visitor\r\n     * @param {boolean} [reverse=false]\r\n     */\r\n    function (tree, test, visitor, reverse) {\r\n      if (typeof test === 'function' && typeof visitor !== 'function') {\r\n        reverse = visitor\r\n        // @ts-expect-error no visitor given, so `visitor` is test.\r\n        visitor = test\r\n        test = null\r\n      }\r\n\r\n      const is = convert(test)\r\n      const step = reverse ? -1 : 1\r\n\r\n      factory(tree, null, [])()\r\n\r\n      /**\r\n       * @param {Node} node\r\n       * @param {number?} index\r\n       * @param {Array<Parent>} parents\r\n       */\r\n      function factory(node, index, parents) {\r\n        /** @type {Record<string, unknown>} */\r\n        // @ts-expect-error: hush\r\n        const value = typeof node === 'object' && node !== null ? node : {}\r\n        /** @type {string|undefined} */\r\n        let name\r\n\r\n        if (typeof value.type === 'string') {\r\n          name =\r\n            typeof value.tagName === 'string'\r\n              ? value.tagName\r\n              : typeof value.name === 'string'\r\n              ? value.name\r\n              : undefined\r\n\r\n          Object.defineProperty(visit, 'name', {\r\n            value:\r\n              'node (' +\r\n              color(value.type + (name ? '<' + name + '>' : '')) +\r\n              ')'\r\n          })\r\n        }\r\n\r\n        return visit\r\n\r\n        function visit() {\r\n          /** @type {ActionTuple} */\r\n          let result = []\r\n          /** @type {ActionTuple} */\r\n          let subresult\r\n          /** @type {number} */\r\n          let offset\r\n          /** @type {Array<Parent>} */\r\n          let grandparents\r\n\r\n          if (!test || is(node, index, parents[parents.length - 1] || null)) {\r\n            result = toResult(visitor(node, parents))\r\n\r\n            if (result[0] === EXIT) {\r\n              return result\r\n            }\r\n          }\r\n\r\n          // @ts-expect-error looks like a parent.\r\n          if (node.children && result[0] !== SKIP) {\r\n            // @ts-expect-error looks like a parent.\r\n            offset = (reverse ? node.children.length : -1) + step\r\n            // @ts-expect-error looks like a parent.\r\n            grandparents = parents.concat(node)\r\n\r\n            // @ts-expect-error looks like a parent.\r\n            while (offset > -1 && offset < node.children.length) {\r\n              // @ts-expect-error looks like a parent.\r\n              subresult = factory(node.children[offset], offset, grandparents)()\r\n\r\n              if (subresult[0] === EXIT) {\r\n                return subresult\r\n              }\r\n\r\n              offset =\r\n                typeof subresult[1] === 'number' ? subresult[1] : offset + step\r\n            }\r\n          }\r\n\r\n          return result\r\n        }\r\n      }\r\n    }\r\n  )\r\n\r\n/**\r\n * @param {VisitorResult} value\r\n * @returns {ActionTuple}\r\n */\r\nfunction toResult(value) {\r\n  if (Array.isArray(value)) {\r\n    return value\r\n  }\r\n\r\n  if (typeof value === 'number') {\r\n    return [CONTINUE, value]\r\n  }\r\n\r\n  return [value]\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}