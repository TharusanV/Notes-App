{"ast":null,"code":"/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n *\r\n * @typedef {string} Type\r\n * @typedef {Object<string, unknown>} Props\r\n *\r\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\r\n */\n\n/**\r\n * Check if a node passes a test\r\n *\r\n * @callback TestFunctionAnything\r\n * @param {Node} node\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {boolean|void}\r\n */\n\n/**\r\n * Check if a node passes a certain node test\r\n *\r\n * @template {Node} X\r\n * @callback TestFunctionPredicate\r\n * @param {Node} node\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {node is X}\r\n */\n\n/**\r\n * @callback AssertAnything\r\n * @param {unknown} [node]\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {boolean}\r\n */\n\n/**\r\n * Check if a node passes a certain node test\r\n *\r\n * @template {Node} Y\r\n * @callback AssertPredicate\r\n * @param {unknown} [node]\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {node is Y}\r\n */\n\nexport const is =\n/**\r\n * Check if a node passes a test.\r\n * When a `parent` node is known the `index` of node should also be given.\r\n *\r\n * @type {(\r\n *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\r\n *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\r\n * )}\r\n */\n\n/**\r\n * Check if a node passes a test.\r\n * When a `parent` node is known the `index` of node should also be given.\r\n *\r\n * @param {unknown} [node] Node to check\r\n * @param {Test} [test]\r\n * When nullish, checks if `node` is a `Node`.\r\n * When `string`, works like passing `function (node) {return node.type === test}`.\r\n * When `function` checks if function passed the node is true.\r\n * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n * When `array`, checks any one of the subtests pass.\r\n * @param {number|null|undefined} [index] Position of `node` in `parent`\r\n * @param {Parent|null|undefined} [parent] Parent of `node`\r\n * @param {unknown} [context] Context object to invoke `test` with\r\n * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\r\n */\n// eslint-disable-next-line max-params\nfunction is(node, test, index, parent, context) {\n  const check = convert(test);\n  if (index !== undefined && index !== null && (typeof index !== 'number' || index < 0 || index === Number.POSITIVE_INFINITY)) {\n    throw new Error('Expected positive finite index');\n  }\n  if (parent !== undefined && parent !== null && (!is(parent) || !parent.children)) {\n    throw new Error('Expected parent node');\n  }\n  if ((parent === undefined || parent === null) !== (index === undefined || index === null)) {\n    throw new Error('Expected both parent and index');\n  }\n\n  // @ts-expect-error Looks like a node.\n  return node && node.type && typeof node.type === 'string' ? Boolean(check.call(context, node, index, parent)) : false;\n};\nexport const convert =\n/**\r\n * @type {(\r\n *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\r\n *   ((test?: Test) => AssertAnything)\r\n * )}\r\n */\n\n/**\r\n * Generate an assertion from a check.\r\n * @param {Test} [test]\r\n * When nullish, checks if `node` is a `Node`.\r\n * When `string`, works like passing `function (node) {return node.type === test}`.\r\n * When `function` checks if function passed the node is true.\r\n * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n * When `array`, checks any one of the subtests pass.\r\n * @returns {AssertAnything}\r\n */\nfunction (test) {\n  if (test === undefined || test === null) {\n    return ok;\n  }\n  if (typeof test === 'string') {\n    return typeFactory(test);\n  }\n  if (typeof test === 'object') {\n    return Array.isArray(test) ? anyFactory(test) : propsFactory(test);\n  }\n  if (typeof test === 'function') {\n    return castFactory(test);\n  }\n  throw new Error('Expected function, string, or object as test');\n};\n/**\r\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\r\n * @returns {AssertAnything}\r\n */\nfunction anyFactory(tests) {\n  /** @type {Array.<AssertAnything>} */\n  const checks = [];\n  let index = -1;\n  while (++index < tests.length) {\n    checks[index] = convert(tests[index]);\n  }\n  return castFactory(any);\n\n  /**\r\n   * @this {unknown}\r\n   * @param {unknown[]} parameters\r\n   * @returns {boolean}\r\n   */\n  function any() {\n    let index = -1;\n    for (var _len = arguments.length, parameters = new Array(_len), _key = 0; _key < _len; _key++) {\n      parameters[_key] = arguments[_key];\n    }\n    while (++index < checks.length) {\n      if (checks[index].call(this, ...parameters)) return true;\n    }\n    return false;\n  }\n}\n\n/**\r\n * Utility to assert each property in `test` is represented in `node`, and each\r\n * values are strictly equal.\r\n *\r\n * @param {Props} check\r\n * @returns {AssertAnything}\r\n */\nfunction propsFactory(check) {\n  return castFactory(all);\n\n  /**\r\n   * @param {Node} node\r\n   * @returns {boolean}\r\n   */\n  function all(node) {\n    /** @type {string} */\n    let key;\n    for (key in check) {\n      // @ts-expect-error: hush, it sure works as an index.\n      if (node[key] !== check[key]) return false;\n    }\n    return true;\n  }\n}\n\n/**\r\n * Utility to convert a string into a function which checks a given node’s type\r\n * for said string.\r\n *\r\n * @param {Type} check\r\n * @returns {AssertAnything}\r\n */\nfunction typeFactory(check) {\n  return castFactory(type);\n\n  /**\r\n   * @param {Node} node\r\n   */\n  function type(node) {\n    return node && node.type === check;\n  }\n}\n\n/**\r\n * Utility to convert a string into a function which checks a given node’s type\r\n * for said string.\r\n * @param {TestFunctionAnything} check\r\n * @returns {AssertAnything}\r\n */\nfunction castFactory(check) {\n  return assertion;\n\n  /**\r\n   * @this {unknown}\r\n   * @param {Array.<unknown>} parameters\r\n   * @returns {boolean}\r\n   */\n  function assertion() {\n    for (var _len2 = arguments.length, parameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      parameters[_key2] = arguments[_key2];\n    }\n    // @ts-expect-error: spreading is fine.\n    return Boolean(check.call(this, ...parameters));\n  }\n}\n\n// Utility to return true.\nfunction ok() {\n  return true;\n}","map":{"version":3,"names":["is","node","test","index","parent","context","check","convert","undefined","Number","POSITIVE_INFINITY","Error","children","type","Boolean","call","ok","typeFactory","Array","isArray","anyFactory","propsFactory","castFactory","tests","checks","length","any","parameters","all","key","assertion"],"sources":["E:/0TUser18/Downloads/Projects/Notes App/client/node_modules/unist-util-is/index.js"],"sourcesContent":["/**\r\n * @typedef {import('unist').Node} Node\r\n * @typedef {import('unist').Parent} Parent\r\n *\r\n * @typedef {string} Type\r\n * @typedef {Object<string, unknown>} Props\r\n *\r\n * @typedef {null|undefined|Type|Props|TestFunctionAnything|Array.<Type|Props|TestFunctionAnything>} Test\r\n */\r\n\r\n/**\r\n * Check if a node passes a test\r\n *\r\n * @callback TestFunctionAnything\r\n * @param {Node} node\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {boolean|void}\r\n */\r\n\r\n/**\r\n * Check if a node passes a certain node test\r\n *\r\n * @template {Node} X\r\n * @callback TestFunctionPredicate\r\n * @param {Node} node\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {node is X}\r\n */\r\n\r\n/**\r\n * @callback AssertAnything\r\n * @param {unknown} [node]\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {boolean}\r\n */\r\n\r\n/**\r\n * Check if a node passes a certain node test\r\n *\r\n * @template {Node} Y\r\n * @callback AssertPredicate\r\n * @param {unknown} [node]\r\n * @param {number|null|undefined} [index]\r\n * @param {Parent|null|undefined} [parent]\r\n * @returns {node is Y}\r\n */\r\n\r\nexport const is =\r\n  /**\r\n   * Check if a node passes a test.\r\n   * When a `parent` node is known the `index` of node should also be given.\r\n   *\r\n   * @type {(\r\n   *   (<T extends Node>(node: unknown, test: T['type']|Partial<T>|TestFunctionPredicate<T>|Array.<T['type']|Partial<T>|TestFunctionPredicate<T>>, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => node is T) &\r\n   *   ((node?: unknown, test?: Test, index?: number|null|undefined, parent?: Parent|null|undefined, context?: unknown) => boolean)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * Check if a node passes a test.\r\n     * When a `parent` node is known the `index` of node should also be given.\r\n     *\r\n     * @param {unknown} [node] Node to check\r\n     * @param {Test} [test]\r\n     * When nullish, checks if `node` is a `Node`.\r\n     * When `string`, works like passing `function (node) {return node.type === test}`.\r\n     * When `function` checks if function passed the node is true.\r\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n     * When `array`, checks any one of the subtests pass.\r\n     * @param {number|null|undefined} [index] Position of `node` in `parent`\r\n     * @param {Parent|null|undefined} [parent] Parent of `node`\r\n     * @param {unknown} [context] Context object to invoke `test` with\r\n     * @returns {boolean} Whether test passed and `node` is a `Node` (object with `type` set to non-empty `string`).\r\n     */\r\n    // eslint-disable-next-line max-params\r\n    function is(node, test, index, parent, context) {\r\n      const check = convert(test)\r\n\r\n      if (\r\n        index !== undefined &&\r\n        index !== null &&\r\n        (typeof index !== 'number' ||\r\n          index < 0 ||\r\n          index === Number.POSITIVE_INFINITY)\r\n      ) {\r\n        throw new Error('Expected positive finite index')\r\n      }\r\n\r\n      if (\r\n        parent !== undefined &&\r\n        parent !== null &&\r\n        (!is(parent) || !parent.children)\r\n      ) {\r\n        throw new Error('Expected parent node')\r\n      }\r\n\r\n      if (\r\n        (parent === undefined || parent === null) !==\r\n        (index === undefined || index === null)\r\n      ) {\r\n        throw new Error('Expected both parent and index')\r\n      }\r\n\r\n      // @ts-expect-error Looks like a node.\r\n      return node && node.type && typeof node.type === 'string'\r\n        ? Boolean(check.call(context, node, index, parent))\r\n        : false\r\n    }\r\n  )\r\n\r\nexport const convert =\r\n  /**\r\n   * @type {(\r\n   *   (<T extends Node>(test: T['type']|Partial<T>|TestFunctionPredicate<T>) => AssertPredicate<T>) &\r\n   *   ((test?: Test) => AssertAnything)\r\n   * )}\r\n   */\r\n  (\r\n    /**\r\n     * Generate an assertion from a check.\r\n     * @param {Test} [test]\r\n     * When nullish, checks if `node` is a `Node`.\r\n     * When `string`, works like passing `function (node) {return node.type === test}`.\r\n     * When `function` checks if function passed the node is true.\r\n     * When `object`, checks that all keys in test are in node, and that they have (strictly) equal values.\r\n     * When `array`, checks any one of the subtests pass.\r\n     * @returns {AssertAnything}\r\n     */\r\n    function (test) {\r\n      if (test === undefined || test === null) {\r\n        return ok\r\n      }\r\n\r\n      if (typeof test === 'string') {\r\n        return typeFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'object') {\r\n        return Array.isArray(test) ? anyFactory(test) : propsFactory(test)\r\n      }\r\n\r\n      if (typeof test === 'function') {\r\n        return castFactory(test)\r\n      }\r\n\r\n      throw new Error('Expected function, string, or object as test')\r\n    }\r\n  )\r\n/**\r\n * @param {Array.<Type|Props|TestFunctionAnything>} tests\r\n * @returns {AssertAnything}\r\n */\r\nfunction anyFactory(tests) {\r\n  /** @type {Array.<AssertAnything>} */\r\n  const checks = []\r\n  let index = -1\r\n\r\n  while (++index < tests.length) {\r\n    checks[index] = convert(tests[index])\r\n  }\r\n\r\n  return castFactory(any)\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @param {unknown[]} parameters\r\n   * @returns {boolean}\r\n   */\r\n  function any(...parameters) {\r\n    let index = -1\r\n\r\n    while (++index < checks.length) {\r\n      if (checks[index].call(this, ...parameters)) return true\r\n    }\r\n\r\n    return false\r\n  }\r\n}\r\n\r\n/**\r\n * Utility to assert each property in `test` is represented in `node`, and each\r\n * values are strictly equal.\r\n *\r\n * @param {Props} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction propsFactory(check) {\r\n  return castFactory(all)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   * @returns {boolean}\r\n   */\r\n  function all(node) {\r\n    /** @type {string} */\r\n    let key\r\n\r\n    for (key in check) {\r\n      // @ts-expect-error: hush, it sure works as an index.\r\n      if (node[key] !== check[key]) return false\r\n    }\r\n\r\n    return true\r\n  }\r\n}\r\n\r\n/**\r\n * Utility to convert a string into a function which checks a given node’s type\r\n * for said string.\r\n *\r\n * @param {Type} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction typeFactory(check) {\r\n  return castFactory(type)\r\n\r\n  /**\r\n   * @param {Node} node\r\n   */\r\n  function type(node) {\r\n    return node && node.type === check\r\n  }\r\n}\r\n\r\n/**\r\n * Utility to convert a string into a function which checks a given node’s type\r\n * for said string.\r\n * @param {TestFunctionAnything} check\r\n * @returns {AssertAnything}\r\n */\r\nfunction castFactory(check) {\r\n  return assertion\r\n\r\n  /**\r\n   * @this {unknown}\r\n   * @param {Array.<unknown>} parameters\r\n   * @returns {boolean}\r\n   */\r\n  function assertion(...parameters) {\r\n    // @ts-expect-error: spreading is fine.\r\n    return Boolean(check.call(this, ...parameters))\r\n  }\r\n}\r\n\r\n// Utility to return true.\r\nfunction ok() {\r\n  return true\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}