{"ast":null,"code":"/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\n\nimport { ok as assert } from 'uvu/assert';\nimport { factoryDestination } from 'micromark-factory-destination';\nimport { factoryLabel } from 'micromark-factory-label';\nimport { factorySpace } from 'micromark-factory-space';\nimport { factoryTitle } from 'micromark-factory-title';\nimport { factoryWhitespace } from 'micromark-factory-whitespace';\nimport { normalizeIdentifier } from 'micromark-util-normalize-identifier';\nimport { markdownLineEnding, markdownLineEndingOrSpace } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\n\n/** @type {Construct} */\nexport const definition = {\n  name: 'definition',\n  tokenize: tokenizeDefinition\n};\n\n/** @type {Construct} */\nconst titleConstruct = {\n  tokenize: tokenizeTitle,\n  partial: true\n};\n\n/** @type {Tokenizer} */\nfunction tokenizeDefinition(effects, ok, nok) {\n  const self = this;\n  /** @type {string} */\n  let identifier;\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.leftSquareBracket, 'expected `[`');\n    effects.enter(types.definition);\n    return factoryLabel.call(self, effects, labelAfter, nok, types.definitionLabel, types.definitionLabelMarker, types.definitionLabelString)(code);\n  }\n\n  /** @type {State} */\n  function labelAfter(code) {\n    identifier = normalizeIdentifier(self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1));\n    if (code === codes.colon) {\n      effects.enter(types.definitionMarker);\n      effects.consume(code);\n      effects.exit(types.definitionMarker);\n\n      // Note: blank lines can’t exist in content.\n      return factoryWhitespace(effects, factoryDestination(effects, effects.attempt(titleConstruct, factorySpace(effects, after, types.whitespace), factorySpace(effects, after, types.whitespace)), nok, types.definitionDestination, types.definitionDestinationLiteral, types.definitionDestinationLiteralMarker, types.definitionDestinationRaw, types.definitionDestinationString));\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function after(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.definition);\n      if (!self.parser.defined.includes(identifier)) {\n        self.parser.defined.push(identifier);\n      }\n      return ok(code);\n    }\n    return nok(code);\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeTitle(effects, ok, nok) {\n  return start;\n\n  /** @type {State} */\n  function start(code) {\n    return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);\n  }\n\n  /** @type {State} */\n  function before(code) {\n    if (code === codes.quotationMark || code === codes.apostrophe || code === codes.leftParenthesis) {\n      return factoryTitle(effects, factorySpace(effects, after, types.whitespace), nok, types.definitionTitle, types.definitionTitleMarker, types.definitionTitleString)(code);\n    }\n    return nok(code);\n  }\n\n  /** @type {State} */\n  function after(code) {\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factoryDestination","factoryLabel","factorySpace","factoryTitle","factoryWhitespace","normalizeIdentifier","markdownLineEnding","markdownLineEndingOrSpace","codes","types","definition","name","tokenize","tokenizeDefinition","titleConstruct","tokenizeTitle","partial","effects","nok","self","identifier","start","code","leftSquareBracket","enter","call","labelAfter","definitionLabel","definitionLabelMarker","definitionLabelString","sliceSerialize","events","length","slice","colon","definitionMarker","consume","exit","attempt","after","whitespace","definitionDestination","definitionDestinationLiteral","definitionDestinationLiteralMarker","definitionDestinationRaw","definitionDestinationString","eof","parser","defined","includes","push","before","quotationMark","apostrophe","leftParenthesis","definitionTitle","definitionTitleMarker","definitionTitleString"],"sources":["E:/0TUser18/Downloads/Projects/Notes App/client/node_modules/micromark-core-commonmark/dev/lib/definition.js"],"sourcesContent":["/**\r\n * @typedef {import('micromark-util-types').Construct} Construct\r\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\r\n * @typedef {import('micromark-util-types').State} State\r\n */\r\n\r\nimport {ok as assert} from 'uvu/assert'\r\nimport {factoryDestination} from 'micromark-factory-destination'\r\nimport {factoryLabel} from 'micromark-factory-label'\r\nimport {factorySpace} from 'micromark-factory-space'\r\nimport {factoryTitle} from 'micromark-factory-title'\r\nimport {factoryWhitespace} from 'micromark-factory-whitespace'\r\nimport {normalizeIdentifier} from 'micromark-util-normalize-identifier'\r\nimport {\r\n  markdownLineEnding,\r\n  markdownLineEndingOrSpace\r\n} from 'micromark-util-character'\r\nimport {codes} from 'micromark-util-symbol/codes.js'\r\nimport {types} from 'micromark-util-symbol/types.js'\r\n\r\n/** @type {Construct} */\r\nexport const definition = {name: 'definition', tokenize: tokenizeDefinition}\r\n\r\n/** @type {Construct} */\r\nconst titleConstruct = {tokenize: tokenizeTitle, partial: true}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeDefinition(effects, ok, nok) {\r\n  const self = this\r\n  /** @type {string} */\r\n  let identifier\r\n\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    assert(code === codes.leftSquareBracket, 'expected `[`')\r\n    effects.enter(types.definition)\r\n    return factoryLabel.call(\r\n      self,\r\n      effects,\r\n      labelAfter,\r\n      nok,\r\n      types.definitionLabel,\r\n      types.definitionLabelMarker,\r\n      types.definitionLabelString\r\n    )(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function labelAfter(code) {\r\n    identifier = normalizeIdentifier(\r\n      self.sliceSerialize(self.events[self.events.length - 1][1]).slice(1, -1)\r\n    )\r\n\r\n    if (code === codes.colon) {\r\n      effects.enter(types.definitionMarker)\r\n      effects.consume(code)\r\n      effects.exit(types.definitionMarker)\r\n\r\n      // Note: blank lines can’t exist in content.\r\n      return factoryWhitespace(\r\n        effects,\r\n        factoryDestination(\r\n          effects,\r\n          effects.attempt(\r\n            titleConstruct,\r\n            factorySpace(effects, after, types.whitespace),\r\n            factorySpace(effects, after, types.whitespace)\r\n          ),\r\n          nok,\r\n          types.definitionDestination,\r\n          types.definitionDestinationLiteral,\r\n          types.definitionDestinationLiteralMarker,\r\n          types.definitionDestinationRaw,\r\n          types.definitionDestinationString\r\n        )\r\n      )\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    if (code === codes.eof || markdownLineEnding(code)) {\r\n      effects.exit(types.definition)\r\n\r\n      if (!self.parser.defined.includes(identifier)) {\r\n        self.parser.defined.push(identifier)\r\n      }\r\n\r\n      return ok(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n}\r\n\r\n/** @type {Tokenizer} */\r\nfunction tokenizeTitle(effects, ok, nok) {\r\n  return start\r\n\r\n  /** @type {State} */\r\n  function start(code) {\r\n    return markdownLineEndingOrSpace(code)\r\n      ? factoryWhitespace(effects, before)(code)\r\n      : nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function before(code) {\r\n    if (\r\n      code === codes.quotationMark ||\r\n      code === codes.apostrophe ||\r\n      code === codes.leftParenthesis\r\n    ) {\r\n      return factoryTitle(\r\n        effects,\r\n        factorySpace(effects, after, types.whitespace),\r\n        nok,\r\n        types.definitionTitle,\r\n        types.definitionTitleMarker,\r\n        types.definitionTitleString\r\n      )(code)\r\n    }\r\n\r\n    return nok(code)\r\n  }\r\n\r\n  /** @type {State} */\r\n  function after(code) {\r\n    return code === codes.eof || markdownLineEnding(code) ? ok(code) : nok(code)\r\n  }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}