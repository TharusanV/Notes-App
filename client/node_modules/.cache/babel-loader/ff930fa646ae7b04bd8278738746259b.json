{"ast":null,"code":"import { isTextSelection, isNodeSelection, posToDOMRect, Extension } from '@tiptap/core';\nimport { Plugin, PluginKey } from 'prosemirror-state';\nimport tippy from 'tippy.js';\nclass BubbleMenuView {\n  constructor(_ref) {\n    let {\n      editor,\n      element,\n      view,\n      tippyOptions = {},\n      shouldShow\n    } = _ref;\n    this.preventHide = false;\n    this.shouldShow = _ref2 => {\n      let {\n        view,\n        state,\n        from,\n        to\n      } = _ref2;\n      const {\n        doc,\n        selection\n      } = state;\n      const {\n        empty\n      } = selection;\n      // Sometime check for `empty` is not enough.\n      // Doubleclick an empty paragraph returns a node size of 2.\n      // So we check also for an empty text size.\n      const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection);\n      // When clicking on a element inside the bubble menu the editor \"blur\" event\n      // is called and the bubble menu item is focussed. In this case we should\n      // consider the menu as part of the ditor and keep showing the menu\n      const isChildOfMenu = this.element.contains(document.activeElement);\n      const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n      if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n        return false;\n      }\n      return true;\n    };\n    this.mousedownHandler = () => {\n      this.preventHide = true;\n    };\n    this.dragstartHandler = () => {\n      this.hide();\n    };\n    this.focusHandler = () => {\n      // we use `setTimeout` to make sure `selection` is already updated\n      setTimeout(() => this.update(this.editor.view));\n    };\n    this.blurHandler = _ref3 => {\n      let {\n        event\n      } = _ref3;\n      var _a;\n      if (this.preventHide) {\n        this.preventHide = false;\n        return;\n      }\n      if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n        return;\n      }\n      this.hide();\n    };\n    this.editor = editor;\n    this.element = element;\n    this.view = view;\n    if (shouldShow) {\n      this.shouldShow = shouldShow;\n    }\n    this.element.addEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n    this.editor.on('focus', this.focusHandler);\n    this.editor.on('blur', this.blurHandler);\n    this.tippyOptions = tippyOptions;\n    // Detaches menu content from its current parent\n    this.element.remove();\n    this.element.style.visibility = 'visible';\n  }\n  createTooltip() {\n    const {\n      element: editorElement\n    } = this.editor.options;\n    const editorIsAttached = !!editorElement.parentElement;\n    if (this.tippy || !editorIsAttached) {\n      return;\n    }\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions\n    });\n    // maybe we have to hide tippy on its own blur event as well\n    if (this.tippy.popper.firstChild) {\n      this.tippy.popper.firstChild.addEventListener('blur', event => {\n        this.blurHandler({\n          event\n        });\n      });\n    }\n  }\n  update(view, oldState) {\n    var _a, _b, _c;\n    const {\n      state,\n      composing\n    } = view;\n    const {\n      doc,\n      selection\n    } = state;\n    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n    if (composing || isSame) {\n      return;\n    }\n    this.createTooltip();\n    // support for CellSelections\n    const {\n      ranges\n    } = selection;\n    const from = Math.min(...ranges.map(range => range.$from.pos));\n    const to = Math.max(...ranges.map(range => range.$to.pos));\n    const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n      editor: this.editor,\n      view,\n      state,\n      oldState,\n      from,\n      to\n    });\n    if (!shouldShow) {\n      this.hide();\n      return;\n    }\n    (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n      getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => {\n        if (isNodeSelection(state.selection)) {\n          const node = view.nodeDOM(from);\n          if (node) {\n            return node.getBoundingClientRect();\n          }\n        }\n        return posToDOMRect(view, from, to);\n      })\n    });\n    this.show();\n  }\n  show() {\n    var _a;\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n  }\n  hide() {\n    var _a;\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n  }\n  destroy() {\n    var _a;\n    (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.destroy();\n    this.element.removeEventListener('mousedown', this.mousedownHandler, {\n      capture: true\n    });\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n    this.editor.off('focus', this.focusHandler);\n    this.editor.off('blur', this.blurHandler);\n  }\n}\nconst BubbleMenuPlugin = options => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n    view: view => new BubbleMenuView({\n      view,\n      ...options\n    })\n  });\n};\nconst BubbleMenu = Extension.create({\n  name: 'bubbleMenu',\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      shouldShow: null\n    };\n  },\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return [];\n    }\n    return [BubbleMenuPlugin({\n      pluginKey: this.options.pluginKey,\n      editor: this.editor,\n      element: this.options.element,\n      tippyOptions: this.options.tippyOptions,\n      shouldShow: this.options.shouldShow\n    })];\n  }\n});\nexport { BubbleMenu, BubbleMenuPlugin, BubbleMenuView, BubbleMenu as default };","map":{"version":3,"mappings":"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","names":["BubbleMenuView","constructor","editor","element","view","tippyOptions","shouldShow","state","from","to","doc","selection","empty","isEmptyTextBlock","textBetween","length","isTextSelection","isChildOfMenu","contains","document","activeElement","hasEditorFocus","hasFocus","isEditable","preventHide","hide","setTimeout","update","event","relatedTarget","parentNode","addEventListener","mousedownHandler","capture","dom","dragstartHandler","on","focusHandler","blurHandler","remove","style","visibility","createTooltip","editorElement","options","editorIsAttached","parentElement","tippy","duration","getReferenceClientRect","content","interactive","trigger","placement","hideOnClick","popper","firstChild","oldState","composing","isSame","eq","ranges","Math","min","map","range","$from","pos","max","$to","setProps","isNodeSelection","node","nodeDOM","getBoundingClientRect","posToDOMRect","show","destroy","removeEventListener","off","Plugin","key","pluginKey","PluginKey","Extension","create","name","addOptions","addProseMirrorPlugins","BubbleMenuPlugin"],"sources":["E:\\0TUser18\\Downloads\\Projects\\Notes App\\client\\node_modules\\@tiptap\\extension-bubble-menu\\src\\bubble-menu-plugin.ts","E:\\0TUser18\\Downloads\\Projects\\Notes App\\client\\node_modules\\@tiptap\\extension-bubble-menu\\src\\bubble-menu.ts"],"sourcesContent":["import {\n  Editor,\n  isNodeSelection,\n  isTextSelection,\n  posToDOMRect,\n} from '@tiptap/core'\nimport { EditorState, Plugin, PluginKey } from 'prosemirror-state'\nimport { EditorView } from 'prosemirror-view'\nimport tippy, { Instance, Props } from 'tippy.js'\n\nexport interface BubbleMenuPluginProps {\n  pluginKey: PluginKey | string,\n  editor: Editor,\n  element: HTMLElement,\n  tippyOptions?: Partial<Props>,\n  shouldShow?: ((props: {\n    editor: Editor,\n    view: EditorView,\n    state: EditorState,\n    oldState?: EditorState,\n    from: number,\n    to: number,\n  }) => boolean) | null,\n}\n\nexport type BubbleMenuViewProps = BubbleMenuPluginProps & {\n  view: EditorView,\n}\n\nexport class BubbleMenuView {\n  public editor: Editor\n\n  public element: HTMLElement\n\n  public view: EditorView\n\n  public preventHide = false\n\n  public tippy: Instance | undefined\n\n  public tippyOptions?: Partial<Props>\n\n  public shouldShow: Exclude<BubbleMenuPluginProps['shouldShow'], null> = ({\n    view,\n    state,\n    from,\n    to,\n  }) => {\n    const { doc, selection } = state\n    const { empty } = selection\n\n    // Sometime check for `empty` is not enough.\n    // Doubleclick an empty paragraph returns a node size of 2.\n    // So we check also for an empty text size.\n    const isEmptyTextBlock = !doc.textBetween(from, to).length\n      && isTextSelection(state.selection)\n\n    // When clicking on a element inside the bubble menu the editor \"blur\" event\n    // is called and the bubble menu item is focussed. In this case we should\n    // consider the menu as part of the ditor and keep showing the menu\n    const isChildOfMenu = this.element.contains(document.activeElement)\n\n    const hasEditorFocus = view.hasFocus() || isChildOfMenu\n\n    if (\n      !hasEditorFocus\n      || empty\n      || isEmptyTextBlock\n      || !this.editor.isEditable\n    ) {\n      return false\n    }\n\n    return true\n  }\n\n  constructor({\n    editor,\n    element,\n    view,\n    tippyOptions = {},\n    shouldShow,\n  }: BubbleMenuViewProps) {\n    this.editor = editor\n    this.element = element\n    this.view = view\n\n    if (shouldShow) {\n      this.shouldShow = shouldShow\n    }\n\n    this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.addEventListener('dragstart', this.dragstartHandler)\n    this.editor.on('focus', this.focusHandler)\n    this.editor.on('blur', this.blurHandler)\n    this.tippyOptions = tippyOptions\n    // Detaches menu content from its current parent\n    this.element.remove()\n    this.element.style.visibility = 'visible'\n  }\n\n  mousedownHandler = () => {\n    this.preventHide = true\n  }\n\n  dragstartHandler = () => {\n    this.hide()\n  }\n\n  focusHandler = () => {\n    // we use `setTimeout` to make sure `selection` is already updated\n    setTimeout(() => this.update(this.editor.view))\n  }\n\n  blurHandler = ({ event }: { event: FocusEvent }) => {\n    if (this.preventHide) {\n      this.preventHide = false\n\n      return\n    }\n\n    if (\n      event?.relatedTarget\n      && this.element.parentNode?.contains(event.relatedTarget as Node)\n    ) {\n      return\n    }\n\n    this.hide()\n  }\n\n  createTooltip() {\n    const { element: editorElement } = this.editor.options\n    const editorIsAttached = !!editorElement.parentElement\n\n    if (this.tippy || !editorIsAttached) {\n      return\n    }\n\n    this.tippy = tippy(editorElement, {\n      duration: 0,\n      getReferenceClientRect: null,\n      content: this.element,\n      interactive: true,\n      trigger: 'manual',\n      placement: 'top',\n      hideOnClick: 'toggle',\n      ...this.tippyOptions,\n    })\n\n    // maybe we have to hide tippy on its own blur event as well\n    if (this.tippy.popper.firstChild) {\n      (this.tippy.popper.firstChild as HTMLElement).addEventListener('blur', event => {\n        this.blurHandler({ event })\n      })\n    }\n  }\n\n  update(view: EditorView, oldState?: EditorState) {\n    const { state, composing } = view\n    const { doc, selection } = state\n    const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection)\n\n    if (composing || isSame) {\n      return\n    }\n\n    this.createTooltip()\n\n    // support for CellSelections\n    const { ranges } = selection\n    const from = Math.min(...ranges.map(range => range.$from.pos))\n    const to = Math.max(...ranges.map(range => range.$to.pos))\n\n    const shouldShow = this.shouldShow?.({\n      editor: this.editor,\n      view,\n      state,\n      oldState,\n      from,\n      to,\n    })\n\n    if (!shouldShow) {\n      this.hide()\n\n      return\n    }\n\n    this.tippy?.setProps({\n      getReferenceClientRect: this.tippyOptions?.getReferenceClientRect || (() => {\n        if (isNodeSelection(state.selection)) {\n          const node = view.nodeDOM(from) as HTMLElement\n\n          if (node) {\n            return node.getBoundingClientRect()\n          }\n        }\n\n        return posToDOMRect(view, from, to)\n      }),\n    })\n\n    this.show()\n  }\n\n  show() {\n    this.tippy?.show()\n  }\n\n  hide() {\n    this.tippy?.hide()\n  }\n\n  destroy() {\n    this.tippy?.destroy()\n    this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true })\n    this.view.dom.removeEventListener('dragstart', this.dragstartHandler)\n    this.editor.off('focus', this.focusHandler)\n    this.editor.off('blur', this.blurHandler)\n  }\n}\n\nexport const BubbleMenuPlugin = (options: BubbleMenuPluginProps) => {\n  return new Plugin({\n    key: typeof options.pluginKey === 'string'\n      ? new PluginKey(options.pluginKey)\n      : options.pluginKey,\n    view: view => new BubbleMenuView({ view, ...options }),\n  })\n}\n","import { Extension } from '@tiptap/core'\n\nimport { BubbleMenuPlugin, BubbleMenuPluginProps } from './bubble-menu-plugin'\n\nexport type BubbleMenuOptions = Omit<BubbleMenuPluginProps, 'editor' | 'element'> & {\n  element: HTMLElement | null,\n}\n\nexport const BubbleMenu = Extension.create<BubbleMenuOptions>({\n  name: 'bubbleMenu',\n\n  addOptions() {\n    return {\n      element: null,\n      tippyOptions: {},\n      pluginKey: 'bubbleMenu',\n      shouldShow: null,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    if (!this.options.element) {\n      return []\n    }\n\n    return [\n      BubbleMenuPlugin({\n        pluginKey: this.options.pluginKey,\n        editor: this.editor,\n        element: this.options.element,\n        tippyOptions: this.options.tippyOptions,\n        shouldShow: this.options.shouldShow,\n      }),\n    ]\n  },\n})\n"]},"metadata":{},"sourceType":"module"}